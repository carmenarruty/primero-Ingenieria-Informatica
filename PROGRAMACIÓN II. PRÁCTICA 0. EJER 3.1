/*
 * PROGRAMA PARA CALCULAR LA RAÍZ CUADRADA Y EL MÁXIMO COMÚN DIVISOR DE DOS NÚMEROS ENTEROS
 * PEDIDOS AL USUARIO/A POR TECLADO.
 *
 * OBJETIVO: DEPURAR USANDO LAS HERRAMIENTAS DE VS CODE. 
 * EL PROGRAMA TIENE COMO MÍNIMO SEIS ERRORES. DOCUMENTAR LAS CORRECCIONES 
 * INTRODUCIDAS, PONIENDO UN COMENTARIO CON LA SENTENCIA INCORRECTA AL
 * LADO DE LA SENTENCIA CORREGIDA
 * 
 * PRUEBAS: USAR LOS SIGUIENTES CASOS PASANDOLOS TANTO COMO ARGUMENTOS COMO DEJANDO QUE EL PROGRAMA PIDA LOS VALORES
 * 10 2 (sqrt=3.162278, gcd=2)
 * 2 10 (sqrt=1.414214, gcd=2)
 * 49 7 (sqrt=7., gcd=7)
 * -5 1 (sqrt no existe por ser negativo, gcd=1)
 * -5 -3 (sqrt no existe por ser negativo, gcd=1)
 * 3 0  (sqrt=1.732051, gcd=3)
 * 0 10 (sqrt=0.000977, gcd=10) // La raíz cuadrada de 0 es 0, pero el método de Newton es un método estimado. Podéis comprobarlo jugando con el parámetro margen
 * 0 0 (sqrt=0.000977, gcd=0)
 */

/* a) Corregir los errores comentando la línea incorrecta y poniendo la correcta a continuación
 * b) Fija un breakpoint e inicia la ejecución en modo depuración ¿Qué sucede al ejecutar paso a paso
 *    (botón “Step into” [F11]) la sentencia donde se invoca la función sqrt()?
 *    RESPUESTA:  Se abre una nueva ventana con el archivo sqrt.c donde se define la función.  En ella se sitúa dentro de la función sqrt, 
 *    se definen y se inician las variables margen y estimacion y se analiza la condición para entrar en el bucle while, por lo que a contienuación, nos situamos
 *    en la función absoluto y una vez finalizada si se cumple la condición se entra en el bucle, una vez acabada la interación se vuelve a analizar la condición volviendo a la función absoluto, 
 *    si se cumple, vuelve a entrar en el bucle, y así continuamente hasta que la condición del bucle while no se cumpla, en ese caso la función devuelve el valor almacenado en la variable estimacion. 
 *    Una vez que finaliza la función se vuelve al main y la variable s del main toma el valor devuelto por la función sqrt, es decir, el valor almacenado en la variable local estimacion. 
 * 
 * c) Al llegar a la función sqrt(), utiliza el botón “STEP OVER” [F10]  en  lugar  del  botón  “Step into” [F11]
 *   ¿Qué  diferencias observas frente a la ejecución del apartado b?
 *   RESPUESTA: Si utilizamos en botón "STEP OVER" no se nos abre ninguna ventana nueva, sino que la variabe s toma el valor que devuelve la función directamente, sin que nosotros 
 *    veamos los pasos que sigue para hacerlo. 
 * 
 * 
 * d) Repite la ejecución en modo depuración visualizando todas las variables. 
 *    Indica qué sucede con la ventana de variables cuando el flujo del programa continúa DENTRO de la función
 *    Justifica la información que aparece en la solapa "Call Stack" (pila de llamada)
 *    RESPUESTA: Una vez entrado en la función sqrt llamada por la función main, 
 *    en el CALL STACK aparece la función de llamada: main(int argc, char** argv) y al lado el fichero .c en el que está implementeda (main.c) junto con la línea en la que fue la llamada a la función sqrt(64:1), 
 *    esto aparecerá en todo momento en el que estemos dentro de la función sqrt llamada por main, junto con la funcón que se está ejecutando sqrt(int numero), la función que fue llamada. 
 *    Además, dentro de la función sqrt tambien se realiza una llamada a otra función, por tanto, en el momento en el que llegamos a la linea 13 en la que se llama a la función absoluto (linea 13), pasamos a la línea donde está definida la función (linea 2) 
 *    y en el CALL STACK aparece tambien la función absoluto(double n), definida en el mismo archivo que la función sqrt. Una vez terminada la función absoluto, esta desaparece del CALL STACK hasta que vuelve a ser llamada por sqrt.  

 *    
 * 
 * */

#include <stdio.h>
#include <stdlib.h>
#include "operaciones.h"

int main(int argc, char** argv) {

    int a, b;
    float s;
    int g; //el máximo común divisor es un entero, y la función gcd tambien devuelve un entero, por tanto hay que definirlo como tal, no como un float 
    
    if (argc < 3){  //argc es un entero que indica cuantos argumentos se pasaron al programa, incluyendo el nombre del programa, por tanto, nunca va a a ser 0. Para poder usar los argumentos, estos deben ser al menos 3 
        printf("Introduce dos números enteros: ");
        scanf("%d%d", &a, &b);   //el primer número no se guardará en a porque no se hace referencia a la direccion de memoria de a. Habría que poner &a 
        //a está defindo como entero, no como float, debemos poner "%d%d" y no "%f%d"
    } else {
        a = atoi(argv[1]); //no podemos poner directamente a= argv[i] , b= argv[i+1] porque a y b están definidos como enteros, mientras que argv[i] contiene los argumentos pasados al programa como strings por tanto no podemos guardar su información en las variables a y b 
        b = atoi(argv[2]);
    } //Además, en argv[0] se guarda el nombre del programa, debería usarse argv[1] y argv[2]. 
    
    if (a >= 0){ //la raiz de cero si que está definida 
        s = sqrt(a);
        printf("\nRaíz cuadrada(%d) = %f\n", a, s);
    }else{
        printf("\nError raíz: el parámetro (%d) no es un entero positivo\n", a);
    }
        
    g = gcd(a, b);
    printf("\nMáximo común divisor(%d,%d) = %d\n\n", a, b, g); //a y g son enteros por tanto debemos poner "%d,%d" y "%d" no "%f,%d" y "%f"
    
    return (EXIT_SUCCESS);
}

